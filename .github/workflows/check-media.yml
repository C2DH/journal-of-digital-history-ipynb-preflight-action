name: Images modification based on language of the notebook

on:
#   push:
#     paths:
#       - 'media/**'      # Trigger when media is modified
  workflow_dispatch:         # Allows manual triggering of the workflow

jobs:
  extract-and-act:
    runs-on: ubuntu-latest

    steps:
      # 1. Prevent Infinite Loops by Skipping Actions Commits
      - name: Prevent Infinite Loop
        if: github.actor == 'github-actions[bot]'
        run: |
          echo "Commit made by GitHub Actions. Skipping workflow execution."
          exit 0

      # 2. Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v3

      # 3. Install jq
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      # 4. Install ImageMagick
      - name: Install ImageMagick
        run: sudo apt-get update && sudo apt-get install -y imagemagick

      # 5. Extract language_info.name using jq
      - name: Extract language_info.name
        id: extract_lang_name
        run: |
          # Extract the language_info.name field
          LANGUAGE_NAME=$(jq -r '.metadata.language_info.name // "Not Found"' article.ipynb)
          
          echo "### Extracted language_info.name: $LANGUAGE_NAME"
          
          # Set the extracted value as an output variable
          echo "lang_name=$LANGUAGE_NAME" >> $GITHUB_OUTPUT

      # Conditional action: If Language is R
      - name: Converting from jpg to png (language=R)
        if: steps.extract_lang_name.outputs.lang_name == 'R'
        run: |
          echo "Language is R. Performing R-specific actions..."
          
          # Navigate to the media directory
          cd media
          
          # Find all .jpeg and .jpg files recursively
          find . -type f \( -iname "*.jpeg" -o -iname "*.jpg" -o -iname "*.webp" -o -iname "*.tiff" -o -iname "*.tif" -o -iname "*.bmp" \) | while read -r file; do
            # Define the new PNG file name
            png_file="${file%.*}.png"
            if [[ ! -f "$png_file" || "$file" -nt "$png_file" ]]; then
            
              
              # Get DPI (X resolution) and dimensions
              dpi_raw=$(identify -format "%x" "$file")
              dpi=$(echo "$dpi_raw" | sed 's/[^0-9.]//g')
              dims=$(identify -format "%w %h" "$file")
              
              width=${dims% *}
              height=${dims#* }

              orig_size=$(stat -c%s "$file")

              # Prepare conversion options based on separate checks
              convert_opts=()
              actions=()

              # Check DPI > 72
              if (( $(echo "$dpi > 72" | bc -l) )); then
                convert_opts+=( -density 72 -units PixelsPerInch )
                actions+=("reset DPI to 72")
              fi

              # Check dimensions > 1920px
              if (( width > 1920 || height > 1920 )); then
                convert_opts+=( -resize '1920x1920>' )
                actions+=("resized to max 1920px")
              fi

              # Always convert to PNG
              convert "$file" "${convert_opts[@]}" "$png_file"

              new_size=$(stat -c%s "$png_file")
              size_diff=$((new_size - orig_size))

              if (( ${#actions[@]} > 0 )); then
                action_msg=$(IFS=" and "; echo "${actions[*]}")
                echo "Converted $file to $png_file: $action_msg."
              else
                echo "Converted $file to $png_file without DPI or size changes."
              fi

              orig_kb=$(awk "BEGIN {printf \"%.1f\", $orig_size/1024}")
              new_kb=$(awk "BEGIN {printf \"%.1f\", $new_size/1024}")
              diff_kb=$(awk "BEGIN {printf \"%+.1f\", $size_diff/1024}")
              printf "Size changed: %d -> %d bytes (%+d bytes), %s KB -> %s KB (%s KB)\n" \
                "$orig_size" "$new_size" "$size_diff" "$orig_kb" "$new_kb" "$diff_kb"

              # Remove the original file
              rm "$file"
              echo "Deleted original file $file"
            else
              echo "Skipped $file; PNG is up-to-date."
            fi
          done
          
      # Conditional Action: If Language is Not R
      - name: Changing the resolution for Python
        if: steps.extract_lang_name.outputs.lang_name != 'R'
        run: |
          echo "Language is Python. Performing image optimization..."

          cd media
    
          find . -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.tiff" -o -iname "*.bmp" -o -iname "*.webp" \) -print0 | while IFS= read -r -d '' orig; do
              # target JPEG path
              base="${orig%.*}"
              jpg="${base}.jpg"

              modified=false
    
              # 1) Convert non-JPEGs to JPEG
              ext="${orig##*.}"
              if [[ ! "${ext,,}" =~ ^jpe?g$ ]]; then
                echo "Converting $orig (non-JPG) to $jpg"
                convert "$orig" -quality 85 "$jpg" && rm "$orig"
                modified=true
                echo "Converted $orig → $jpg"
              else
                echo "$orig is already in JPG format; skipping conversion"
                jpg="$orig"
              fi
    
              # guard against empties / missing
              [ -z "$jpg" ] && continue
              [ ! -f "$jpg" ] && continue
    
              # 2) size before
              size_before=$(stat -c%s "$jpg")
    
              # 3) DPI normalization
              dpi=$(identify -format "%x" "$jpg" | awk '{print int($1)}')
              if [ "$dpi" -gt 72 ]; then
                echo "Converting DPI to 72"
                mogrify -density 72 "$jpg"
                modified=true
                echo "↓ DPI of $jpg: $dpi → 72"
              fi
    
              # 4) dimension downscaling

              dims=$(identify -format "%w %h" "$jpg")
              
              width=${dims% *}
              height=${dims#* }
              
              echo "width height read; $width $height"
              if [ "$width" -gt 1920 ] || [ "$height" -gt 1920 ]; then
                mogrify -filter Lanczos -resize '1920x1920>' "$jpg"
                modified=true
                echo "Resized $jpg to max 1920px"
              fi

              new_size=$(stat -c%s "$jpg)
              size_diff=$((new_size - orig_size))
    
              orig_kb=$(awk "BEGIN {printf \"%.1f\", $orig_size/1024}")
              new_kb=$(awk "BEGIN {printf \"%.1f\", $new_size/1024}")
              diff_kb=$(awk "BEGIN {printf \"%+.1f\", $size_diff/1024}")
              printf "Size changed: %d -> %d bytes (%+d bytes), %s KB -> %s KB (%s KB)\n" \
                "$orig_size" "$new_size" "$size_diff" "$orig_kb" "$new_kb" "$diff_kb"
          done
      # Notify the Result
      - name: Notify Result
        run: |
          if [ "${{ steps.extract_lang_name.outputs.lang_name }}" = "R" ]; then
            echo "has R as language"
          else
            echo "doesn't have R as running language"
          fi
      - name: Commit and Push Changes (R)
        if: steps.extract_lang_name.outputs.lang_name == 'R'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
            commit_message: "Convert JPEG images to PNG 72dpi format"
            branch: ${{ github.ref_name }} # Ensures commits are made to the current branch
        
      - name: Commit and Push Changes (Python)
        if: steps.extract_lang_name.outputs.lang_name != 'R'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
            commit_message: "Convert all images to .jpg and 72dpi format (unless they had a smaller dpi)"
            branch: ${{ github.ref_name }} # Ensures commits are made to the current branch
